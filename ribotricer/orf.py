"""Utilities for translating ORF detection"""

# Part of ribotricer software
#
# Copyright (C) 2020 Saket Choudhary, Wenzheng Li, and Andrew D Smith
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

from __future__ import annotations

import sys
from typing import TYPE_CHECKING

from .interval import Interval

if TYPE_CHECKING:
    from .gtf import GTFTrack


class ORF:
    """Class for candidate ORF.

    Attributes
    ----------
    category : str
        ORF category (e.g., 'annotated', 'uORF', 'dORF', etc.).
    tid : str
        Transcript ID.
    ttype : str
        Transcript type.
    gid : str
        Gene ID.
    gname : str
        Gene name.
    gtype : str
        Gene type.
    chrom : str
        Chromosome name.
    strand : str
        Strand ('+' or '-').
    intervals : list[Interval]
        List of intervals comprising the ORF.
    oid : str
        ORF ID (auto-generated).
    seq : str
        ORF sequence.
    leader : str
        5' UTR sequence.
    trailer : str
        3' UTR sequence.
    """

    __slots__ = (
        "category",
        "tid",
        "ttype",
        "gid",
        "gname",
        "gtype",
        "chrom",
        "strand",
        "intervals",
        "oid",
        "seq",
        "leader",
        "trailer",
    )

    def __init__(
        self,
        category: str,
        transcript_id: str,
        transcript_type: str,
        gene_id: str,
        gene_name: str,
        gene_type: str,
        chrom: str,
        strand: str,
        intervals: list[Interval],
        seq: str = "",
        leader: str = "",
        trailer: str = "",
    ) -> None:
        self.category = category
        self.tid = transcript_id
        self.ttype = transcript_type
        self.gid = gene_id
        self.gname = gene_name
        self.gtype = gene_type
        self.chrom = chrom
        self.strand = strand
        self.intervals = sorted(intervals, key=lambda x: x.start)
        start = self.intervals[0].start
        end = self.intervals[-1].end
        self.oid = "{}_{}_{}_{}".format(
            transcript_id,
            start,
            end,
            sum([x.end - x.start + 1 for x in self.intervals]),
        )
        self.seq = seq
        self.leader = leader
        self.trailer = trailer

    @property
    def start_codon(self) -> str | None:
        """Return the first 3 bases from sequence.

        Returns
        -------
        str | None
            The start codon sequence, or None if sequence is too short.
        """
        if len(self.seq) < 3:
            return None
        return self.seq[:3]

    @classmethod
    def from_string(cls, line: str) -> ORF | None:
        """Create ORF from a ribotricer index file line.

        Parameters
        ----------
        line : str
            Line from ribotricer index file generated by prepare_orfs.

        Returns
        -------
        ORF | None
            Parsed ORF object, or None if parsing fails.

        Notes
        -----
        This method uses a fail-fast strategy and hence multiple
        returns. It ultimately returns an object corresponding to the
        parsed line.
        """
        if not line:
            print("annotation line cannot be empty")
            return None
        fields = line.split("\t")
        if len(fields) != 11:
            sys.exit(
                "{}\n{}".format(
                    "Error: unexpected number of columns found for index file",
                    "please run ribotricer prepare-orfs to regenerate",
                )
            )
            return None
        # ADS: oid below is not used
        oid = fields[0]  # noqa F841
        category = fields[1]
        tid = fields[2]
        ttype = fields[3]
        gid = fields[4]
        gname = fields[5]
        gtype = fields[6]
        chrom = fields[7]
        strand = fields[8]
        start_codon = fields[9]
        coordinate = fields[10]
        intervals: list[Interval] = []
        for group in coordinate.split(","):
            start, end = group.split("-")
            start_pos = int(start)
            end_pos = int(end)
            intervals.append(Interval(chrom, start_pos, end_pos, strand))
        return cls(
            category,
            tid,
            ttype,
            gid,
            gname,
            gtype,
            chrom,
            strand,
            intervals,
            seq=start_codon,
        )

    @classmethod
    def from_tracks(
        cls,
        tracks: list[GTFTrack],
        category: str,
        seq: str = "",
        leader: str = "",
        trailer: str = "",
    ) -> ORF | None:
        """Create ORF from a list of GTF tracks.

        Parameters
        ----------
        tracks : list[GTFTrack]
            List of GTF track objects.
        category : str
            ORF category.
        seq : str, optional
            ORF sequence.
        leader : str, optional
            5' UTR sequence.
        trailer : str, optional
            3' UTR sequence.

        Returns
        -------
        ORF | None
            Parsed ORF object, or None if parsing fails.

        Notes
        -----
        This method uses a fail-fast strategy and hence multiple
        returns. It ultimately returns an object corresponding to the
        parsed line.
        """
        if not tracks:
            return None
        intervals: list[Interval] = []
        tid: set[str] = set()
        ttype: set[str] = set()
        gid: set[str] = set()
        gname: set[str] = set()
        gtype: set[str] = set()
        chrom: set[str] = set()
        strand: set[str] = set()
        required_attributes = [
            "transcript_id",
            "transcript_type",
            "gene_id",
            "gene_name",
            "gene_type",
            "chrom",
            "strand",
        ]
        for track in tracks:
            try:
                tid.add(track.transcript_id)
                ttype.add(track.transcript_type)
                gid.add(track.gene_id)
                gname.add(track.gene_name)
                gtype.add(track.gene_type)
                chrom.add(track.chrom)
                strand.add(track.strand)
                intervals.append(
                    Interval(track.chrom, track.start, track.end, track.strand)
                )
            except AttributeError:
                for attribute in required_attributes:
                    if not hasattr(track, attribute):
                        print('missing attribute "{}" in {}'.format(attribute, track))
                        return None
        if (
            len(tid) != 1
            or len(ttype) != 1
            or len(gid) != 1
            or len(gname) != 1
            or len(gtype) != 1
            or len(chrom) != 1
            or len(strand) != 1
        ):
            print("inconsistent tracks for ORF: {}".format(track))
            return None
        tid_val = list(tid)[0]
        ttype_val = list(ttype)[0]
        gid_val = list(gid)[0]
        gname_val = list(gname)[0]
        gtype_val = list(gtype)[0]
        chrom_val = list(chrom)[0]
        strand_val = list(strand)[0]
        return cls(
            category,
            tid_val,
            ttype_val,
            gid_val,
            gname_val,
            gtype_val,
            chrom_val,
            strand_val,
            intervals,
            seq,
            leader,
            trailer,
        )
